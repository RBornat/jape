/*
        This jape theory file was generated from the
        latex source of the paper -- ``JnJ in Jape'' --
        which describes the way in which the logic of the
        Woodcock/Davies book is encoded in Jape. A full
        explanation of how the Jape encoding
        may be used with the book is given in that paper,
        and a description of using the logic with the X
        implementation of Jape is given in the
        companion paper ``Using JnJ in Unix Jape''.

        $Id$
*/
        FONTS   "Konstanz"
        SEQUENT IS BAG Ê FORMULA
        INITIALISE autoAdditiveLeft true
        PREFIX   350 ¬
        INFIX    50R  Í
        INFIX    100R Á
        INFIX    200L Î
        INFIX    300L ¶
        JUXTFIX  4000
        CLASS FORMULA  p q r s
        CLASS VARIABLE x y z
        CONSTANT false true
        SUBSTFIX 5000 [ p / x ]
        RULE  "¶-intro"  FROM p AND q INFER p¶q
        RULE  "¶-elim1"  FROM p¶q INFER p
        RULE  "¶-elim2"  FROM p¶q INFER q

        RULE  "Î-intro1" FROM p INFER pÎq
        RULE  "Î-intro2" FROM q INFER pÎq
        RULE  "Î-elim"   FROM pÎq AND pÊr AND qÊr INFER r

        RULE  "Á-intro"  FROM p Ê q INFER pÁq
        RULE  "Á-elim"   FROM pÁq AND p INFER q

        RULE  "¬-intro"  FROM p Ê false INFER ¬ p
        RULE  "¬-elim"   FROM ¬p AND p INFER false

        RULE  "false-elim" FROM ¬p Ê false INFER  p
        RULE  "true-intro" INFER  Ê true

        RULE  "Í-intro"  FROM p Á q AND   q Á p INFER p Í q
        RULE  "Í-elim1"  FROM p Í q INFER p Á q
        RULE  "Í-elim2"  FROM p Í q INFER q Á p
        RULE hypothesis(p) INFER p Ê p
        RULE cut(p)        FROM  Ê p AND   p Ê q  INFER   Ê q
        RULE thin(p)       FROM  Ê q              INFER p Ê q
        RULE dup(p)        FROM  p, p Ê q         INFER p Ê q
        IDENTITY RULE hypothesis
        CUT      RULE cut
        WEAKEN   RULE thin
    INFIX   1000R ⁄
    LEFTFIX 20    Ë : •
    LEFTFIX 20    Ë : | •
    LEFTFIX 20    ‰ : •
    LEFTFIX 20    ‰ : | •
    CLASS FORMULA a b t
    BIND x SCOPE p IN Ë x:a • p
    BIND x SCOPE p q IN Ë x:a | p • q
    BIND x SCOPE p IN ‰ x:a • p
    BIND x SCOPE p q IN ‰ x:a | p • q
    RULE    "Ë-intro"(OBJECT y) WHERE FRESH y
    FROM    y⁄a Ê q[y/x]
    INFER   Ë x:a • q
    RULE    "Ë-elim"(t)
    FROM    Ë x:a • q
    AND     t⁄a
    INFER   q[t/x]
    RULE    "‰-intro"(t)
    FROM    t⁄a
    AND     q[t/x]
    INFER   ‰ x:a • q
    RULE    "‰-elim"(OBJECT y)
    WHERE   FRESH y
    AND     y NOTIN ‰ x:a • p
    AND     y NOTIN r
    FROM    ‰ x:a • p
    AND     y⁄a, p[y/x] Ê r
    INFER   r
    RULE "Ë|•-intro" IS FROM Ë x:a • p Á q INFER Ë x:a|p•q
    RULE "Ë|•-elim"  IS FROM Ë x:a | p • q INFER Ë x:a•pÁq
    RULE "‰|•-intro" IS FROM ‰ x:a • p ¶ q INFER ‰ x:a|p•q
    RULE "‰|•-elim"  IS FROM ‰ x:a | p • q INFER ‰ x:a•p¶q
    TACTIC ElimRule(rule)
    (WHEN
      (LETHYP _p
          (ALT (SEQ      (WITHARGSEL rule) (WITHHYPSEL hypothesis))
               (SEQ  cut (WITHARGSEL rule) (WITHHYPSEL hypothesis))
               (Fail ("%s is not applicable to formula %s", rule, _p))))
      (LETCONC _p
          (ElimRuleBackward rule))
      (Fail ("Select an assumption-like formula before applying %s forwards", rule)))
    TACTIC IntroRule(rule)
    (WHEN  (LETARGSEL _p (SEQ (cut _p) rule))
           (ALT (LETHYP    _p rule)
                rule
                (MESSAGE (rule is not applicable))))
    TACTIC QuantIntroRule(rule)
    (ALT (WITHARGSEL rule)
         (Fail ("%s is not applicable", rule)))
    MENU    "Propositional Rules"

    ENTRY   "hypothesis"
    SEPARATOR
    ENTRY    "false-elim"   IS (IntroRule "false-elim")
    SEPARATOR
    SEPARATOR
    ENTRY    "¶-intro"      IS (IntroRule "¶-intro")
    TACTIC   "¶-elim-1"     IS (ElimRule  "¶-elim1")
    ENTRY    "¶-elim-2"     IS (ElimRule  "¶-elim2")
    SEPARATOR
    ENTRY    "Î-intro1"     IS (IntroRule "Î-intro1")
    ENTRY    "Î-intro2"     IS (IntroRule "Î-intro2")
    ENTRY    "Î-elim"       IS (ElimRule "Î-elim")
    SEPARATOR
    ENTRY    "Á-intro"      IS (IntroRule "Á-intro")
    ENTRY    "Á-elim"       IS (ElimRule  "Á-elim")
    SEPARATOR
    ENTRY    "¬-intro"      IS (IntroRule "¬-intro")
    ENTRY    "¬-elim"       IS (ElimRule "¬-elim")
    ENTRY    "true-intro"   IS (IntroRule "true-intro")
    SEPARATOR
    ENTRY    "Í-intro"      IS (IntroRule "Í-intro")
    ENTRY    "Í-elim1"      IS (ElimRule "Í-elim1")
    ENTRY    "Í-elim2"      IS (ElimRule "Í-elim2")
END

MENU "Predicate Rules" IS
    ENTRY "Ë-intro"   IS QuantIntroRule "Ë-intro"
    ENTRY "Ë-elim"    IS ElimRule "Ë-elim"
    ENTRY "‰-intro"   IS QuantIntroRule "‰-intro"
    ENTRY "‰-elim"    IS ElimRule "‰-elim"
    ENTRY "‰|•-intro" IS QuantIntroRule "‰|•-intro"
    ENTRY "‰|•-elim"  IS ElimRule "‰|•-elim"
    ENTRY "Ë|•-intro" IS QuantIntroRule "Ë|•-intro"
    ENTRY "Ë|•-elim"  IS ElimRule "Ë|•-elim"
END
    AUTOMATCH hypothesis
    HYPHIT pÎq Ê r IS  (ALT (ElimRule "Î-elim")  "Î-elim")
    HYPHIT pÁq Ê r IS  (ALT (ElimRule "Á-elim")  "Á-elim")
    HYPHIT ¬p  Ê r IS  (ALT (ElimRule "¬-elim")  "¬-elim")
    HYPHIT Ëx:a|p•q Ê r IS ElimRule "Ë|•-elim"
    HYPHIT ‰x:a|p•q Ê r IS ElimRule "‰|•-elim"
    HYPHIT Ëx:a•q   Ê r IS ElimRule "Ë-elim"
    HYPHIT ‰x:a•q   Ê r IS ElimRule "‰-elim"
    HYPHIT p¶q Ê r IS
    (ALT (SEQ  "¶-elim1"  (hypothesis(p¶q)))
         (SEQ  "¶-elim2"  (hypothesis(p¶q)))
         (SEQ
               cut "¶-elim1" (hypothesis (p¶q))
               cut "¶-elim2" (hypothesis (p¶q))
         ))

    HYPHIT pÍq Ê r IS
    (ALT (SEQ  "Í-elim1"  (hypothesis(pÍq)))
         (SEQ  "Í-elim2"  (hypothesis(pÍq)))
         (SEQ
               cut "Í-elim1" (hypothesis (pÍq))
               cut "Í-elim2" (hypothesis (pÍq))
         ))
    CONCHIT Ëx:a|p•q IS QuantIntroRule "Ë|•-intro"
    CONCHIT ‰x:a|p•q IS QuantIntroRule "‰|•-intro"
    CONCHIT Ëx:a•q   IS QuantIntroRule "Ë-intro"
    CONCHIT ‰x:a•q   IS QuantIntroRule "‰-intro"
    CONCHIT ¬p       IS "¬-intro"
    CONCHIT true     IS "true-intro"
    CONCHIT pÁq      IS "Á-intro"
    CONCHIT pÍq      IS "Í-intro"
    CONCHIT p¶q      IS "¶-intro"
    CONCHIT qÎr      IS
     (ALT  (SEQ "Î-intro1" hypothesis)
           (SEQ "Î-intro2" hypothesis)
           (MESSAGE (Neither disjunct q nor disjunct r is available)))

    CONCHIT  p Ê p IS
    (WHEN (LETHYP _p (WITHHYPSEL hypothesis))
          (Fail ("Please select the hypothesis you want to use")))
    MENU Edit
        RADIOBUTTON displaystyle
             "Sequent-Tree display style"  IS tree
        AND  "Box display style"           IS box
        INITIALLY
             box
        END

        RADIOBUTTON autoselect
            "Manual goal selection"    IS false
        AND "Automatic goal selection" IS true
        END

        RADIOBUTTON applyconjectures
            "Only proven theorems may be used as rules" IS false
        AND "Unproven theorems may be used as rules"    IS true
        END

        RADIOBUTTON ElimRuleBackward
            "Forbid backward use of elimination rules" IS
               ElimRuleBackwardNo
        AND "Permit backward use of elimination rules" IS
               ElimRuleBackwardYes
        END

    END /* MENU Edit */

    TACTIC ElimRuleBackwardYes(rule)
           (WITHARGSEL rule)

    TACTIC ElimRuleBackwardNo(rule)
    (Fail ("Select a goal then a non-grey formula before invoking %s",
           rule))
    TACTIC Fail(x) IS
           ((SEQ (ALERT x) FAIL))
    TACTIC FAILSEL(x, y) IS
           (WHEN (LETARGSEL _p ((SEQ (ALERT x) FAIL))) ((SEQ (ALERT y) FAIL)))
    TACTIC MESSAGE(m) IS
<<<<<<< jnjkonstanz.jt
    (SEQ (COMMENT m)
         (EXPLAIN m))
=======
      SEQ (COMMENT m) (EXPLAIN m)
>>>>>>> 1.2

    TACTIC SKIP(x)    IS (SEQ)

    MENU    Edit
            SEPARATOR
            RADIOBUTTON Comment IS
                    "Comments on during tactics"  COMMENT
            AND     "Comments off during tactics" SKIP
            END
    END
        INFIX 1000L ë
CONJECTUREPANEL "Conjectures" IS
    THEOREMS Propositional ARE
        ¬¬p Ê p
    AND ¬(pÎq) Ê ¬p ¶ ¬q
    AND ¬(p¶q) Ê ¬p Î ¬q
    AND Ê p Î ¬p
    AND p , ¬p Ê false
    AND p ¶ ¬p Ê false
    AND p Ê qÁp
    AND Ê pÍp
    AND ¬ ¬ p Í p
    AND (pÁq) Í (¬pÎq)
    AND (pÁq) Í (¬qÁ¬p)
    AND Ê (pÁq) Î (qÁp)
    AND (p¶q Á r) Á (p Á (q Á r))
    AND p Á q Ê p¶q Í p
    AND Ê p Á (q Á p)
    AND true  Í ¬false
    AND ¬true  Í false
    AND p¶true Í p
    AND pÎtrue Í true
    AND p¶false Í false
    AND pÎfalse Í p
    AND (pÁp) Í true
    AND (pÁtrue) Í true
    AND (trueÁp) Í p
    AND (pÁfalse) Í ¬p
    AND (p¶p) Í p
    AND (p¶q) Í (q¶p)
    AND (p¶(q¶r)) Í ((p¶q)¶r)
    AND (pÎp) Í p
    AND (pÎq) Í (qÎp)
    AND (pÎ(qÎr)) Í ((pÎq)Îr)
    AND p Î (q Î r) Í (p Î q) Î r
    AND p ¶ (q Î r) Í (p ¶ q) Î (p ¶ r)
    AND p Î (q ¶ r) Í (p Î q) ¶ (p Î r)
    AND ¬(pÎq) Í ¬p ¶ ¬q
    AND ¬(p¶q) Í ¬p Î ¬q
    AND (pÁq) ¶ (qÁr) Á (pÁr)
    AND (pÍq) ¶ (qÍr) Á (pÍr)
    AND ¬p ¶ p Ê false
    AND ¬(pÍq)Í((pÎq)¶¬(p¶q))
    AND Ëx:a • p¶q Ê (Ëx:a • p) ¶ (Ëx:a • q)
    AND (Ëx:a • p) ¶ (Ëx:a • q) Ê Ëx:a • p¶q
    AND ¬(‰ x:a•q) Ê (Ë x:a•¬q)
    AND ¬(Ë x:a•q) Ê (‰ x:a•¬q)
    AND ¬(Ë x:a|p•q) Ê (‰ x:a|p•¬q)
    AND WHERE x NOTIN a,a',y AND y NOTIN a,a',x INFER
        ‰x:a • Ëy:a' • q Ê Ëy:a' • ‰x:a • q
    AND p Á q, q Á r , p Ê r
    AND p Á q Ê (q Á r) Á (p Á r)
    AND p Á (q Á r), p Á q, p Ê r
    AND p Á q, q Á r Ê p Á r
    AND p Á (q Á r) Ê q Á (p Á r)
    AND p Á (q Á (r Á s)) Ê r Á (q Á (p Á s ))
    AND p Á (q Á r) Ê (p Á q) Á (p Á r)
    AND Ê (p Á (q Á r)) Á ((p Á q) Á (p Á r))
    AND (p ¶ q) Á r Í  p Á (q Á r)
    AND q Á r Ê (p Î q) Á (p Î r)
    END
    THEOREM "?-‰x:a•Ëy:a'•xëyÊËy:a'•‰x:a•xëy(no provisos)"
    IS ‰ x:a • Ëy:a' • xëy Ê Ëy:a' • ‰x:a • xëy
    THEOREM "?- (pÁq)Áp" IS (pÁq)Áp
    THEOREM "?- (pÎ¬p)Á¬p" IS (pÎ¬p)Á¬p
    THEOREM "?- Ëy:a'•‰x:a•q Ê ‰x:a•Ëy:a'•q"
    WHERE x NOTIN a,a',y AND y NOTIN a,a',x
    IS Ëy:a'•‰x:a•q Ê ‰x:a•Ëy:a'•q
    BUTTON "Apply Forward"   IS apply ThmForward COMMAND
    BUTTON "Apply Backwards" IS apply ThmBackward COMMAND
END /* PANEL */
    TACTIC ThmForward(thm) IS (SEQ cut (WITHHYPSEL (WITHARGSEL thm)))
    TACTIC ThmBackward(thm) IS (WITHARGSEL(APPLYORRESOLVE thm))
        RULE    "rewrite"(p, OBJECT x) WHERE FRESH x
        FROM    p Í q
        AND     r[q/x]
        INFER   r[p/x]

        RULE    "rewritebackwards"(p, OBJECT x) WHERE FRESH x
        FROM    q Í p
        AND     r[q/x]
        INFER   r[p/x]

        RULE    "hyprewrite"(p, OBJECT x) WHERE FRESH x
        FROM    p Í q
        AND     r[p/x] Ê s
        INFER   r[q/x] Ê s

        RULE    "hyprewritebackwards"(p, OBJECT x) WHERE FRESH x
        FROM    q Í p
        AND     r[p/x] Ê s
        INFER   r[q/x] Ê s
    CONJECTUREPANEL Conjectures IS
   BUTTON "Rewrite «" IS
      apply RewriteWith Unfolding hyprewrite   rewrite COMMAND
     BUTTON "Rewrite »" IS
      apply RewriteWith Folding   hyprewritebackwards rewritebackwards COMMAND
    END
    TACTIC  RewriteWith(foldunfold, hyprewriterule, rewriterule, thm) IS
    (LAYOUT "rewrite %s" (1)
      (ALT
        (WHEN
          (LETHYPSUBSTSEL  _p (WITHSUBSTSEL hyprewriterule) thm)
          (LETCONCSUBSTSEL _p (WITHSUBSTSEL rewriterule) thm))
        (foldunfold thm)
        (FAILSEL ("%s not applicable to text selection", thm)
                 ("%s not applicable anywhere by foldunfold", thm))))
    TACTIC Unfolding(thm) IS (UNFOLD rewrite thm)
    TACTIC Folding(thm)   IS (FOLD   rewritebackwards thm)
    MENU Rewriting
    ENTRY    "Rewrite â"  IS
                Rewrite rewrite hyprewrite
    ENTRY    "Rewrite Å"  IS
                Rewrite rewritebackwards hyprewritebackwards
    END

    TACTIC  Rewrite(rule, hyprule) IS
    (WHEN   (LETHYPSUBSTSEL  _p (WITHSUBSTSEL hyprule))
            (LETCONCSUBSTSEL _p (WITHSUBSTSEL rule))
            (Fail (Please text-select a subexpression to rewrite)))

CONJECTUREPANEL "Derived rules"
    DERIVED RULE /* WHERE FRESH z */ FROM z⁄aÊp[z/x]Íq[z/x] AND Ëx:a•p INFER Ëx:a•q
END
    
TACTIC GivenForward(i) IS SEQ cut (GIVEN i)
TACTIC GivenBackward(i) IS GIVEN i

GIVENPANEL Given IS
    BUTTON "Apply Forward"   IS apply GivenForward COMMAND
    BUTTON "Apply Backwards" IS apply GivenBackward COMMAND
END /* GIVENPANEL */

