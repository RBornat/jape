/*
    $Id$

    Copyright (C) 2020 Richard Bornat
     
        richard@bornat.me.uk

    This file is part of the Aristotleian deductive logic encoding, distributed with jape.

    Jape is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    Jape is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with jape; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    (or look at http://www.gnu.org).

*/

/* Aristotle's deductive logic according to von Plato, modified by Roy Dyckhoff.
   Transcribed by RB, 07/2020
 */

USE "Syllogisms syntax.j"
USE "Syllogisms rules.j"

INITIALISE autoAdditiveLeft true
INITIALISE displaystyle box
INITIALISE outermostbox false

INITIALISE outerassumptionword " assumption"
INITIALISE innerassumptionword " (contradictory) assumption"

INITIALISE multiassumptionlines false

INITIALISE hidecut true
INITIALISE hidehyp false
INITIALISE hidehypprev true

INITIALISE multihypsel true

TACTIC "hyp-quiet" IS (LAYOUT " " () hyp)
AUTOMATCH "hyp-quiet"

TACTIC "hyp-quiet2"(A) IS (LAYOUT " " () (hyp A))

RULE vp1 IS FROM ∏⁺(P,S) INFER ∑⁺(S,P)
RULE vp2 IS FROM ∏⁻(P,S) INFER ∏⁻(S,P)
RULE Barbara(M) IS FROM ∏⁺(M,P) AND ∏⁺(S,M) INFER ∏⁺(S,P)
RULE Celarent(M) IS FROM ∏⁻(M,P) AND ∏⁺(S,M) INFER ∏⁻(S,P)

MACRO "Syllogism-step" (rule, hpat1, hpat2, mpat) IS
  SEQ (LAYOUT " " ALL (rule mpat)) (WITHHYPSEL ("hyp-quiet2" (hpat1))) (WITHHYPSEL ("hyp-quiet2" (hpat2)))
  
MACRO "Syllogism-tac" (rule, hpat1, hpat2, mpat, cpat) IS
  WHEN (LETHYP2 hpat1 hpat2
          (WHEN (LETCONC _A ("Syllogism-step" rule hpat1 hpat2 mpat))
                (CUTIN ("Syllogism-step" rule hpat1 hpat2 mpat))
          )
       )
       (LETHYP2 _A _B
          (Fail ("%t is not applicable to the hypotheses %t and %t", rule, _A, _B))
       )
       (LETGOAL cpat
          (WHEN (LETHYP hpat1 (LAYOUT " " ALL (rule mpat)) (WITHHYPSEL ("hyp-quiet2" (hpat1))))
                (LETHYP hpat2 (LAYOUT " " ALL (rule mpat)) SKIP (WITHHYPSEL ("hyp-quiet2" (hpat2))))
                (LETHYP _A (Fail ("%t is not applicable to the goal %t and hypothesis %t", rule, cpat, _A)))
                (LAYOUT " " ALL rule)
          )
       )
       (LETGOAL _A (Fail ("%t does not infer the goal %t", rule, _A)))
       (Fail "can't happen: Syllogism-tac out of alternatives")
       
RULES contra ARE
      FROM ∏⁺(S,P) INFER ∑⁻(S,P)*
  AND FROM ∏⁻(S,P) INFER ∑⁺(S,P)*      
  AND FROM ∑⁺(S,P) INFER ∏⁻(S,P)*
  AND FROM ∑⁻(S,P) INFER ∏⁺(S,P)*
END

RULES ccontra ARE
      FROM ∑⁻(S,P)* INFER ∏⁺(S,P)
  AND FROM ∑⁺(S,P)* INFER ∏⁻(S,P)      
  AND FROM ∏⁻(S,P)* INFER ∑⁺(S,P)
  AND FROM ∏⁺(S,P)* INFER ∑⁻(S,P)
END
  
RULES equiv ARE
      FROM ∏⁻(S,P) INFER ∏⁻(P,S)
  AND FROM ∑⁺(S,P) INFER ∑⁺(P,S)
END

RULES subaltern ARE
      FROM ∏⁺(S,P) INFER ∑⁺(S,P)
  AND FROM ∏⁻(S,P) INFER ∑⁻(S,P)
END

TACTIC "contra-tac" IS LAYOUT HIDEROOT contra

AUTOMATCH "contra-tac"

MENU Rules IS
  ENTRY "(vp1) ∏⁺(P,S) ⇒ ∑⁺(S,P)"               IS ForwardOrBackward ForwardCut 0 (LAYOUT " " ALL vp1)
  ENTRY "(vp2, conversion) ∏⁻(P,S) ⇒ ∏⁻(S,P)"   IS ForwardOrBackward ForwardCut 0 (LAYOUT " " ALL vp2)
  ENTRY "(Barbara) ∏⁺(M,P), ∏⁺(S,M) ⇒ ∏⁺(S,P)"  IS "Syllogism-tac" Barbara (∏⁺(_M,_P)) (∏⁺(_S,_M)) _M (∏⁺(_S,_P))
  ENTRY "(Celarent) ∏⁻(M,P), ∏⁺(S,M) ⇒ ∏⁻(S,P)" IS "Syllogism-tac" Celarent (∏⁻(_M,_P)) (∏⁺(_S,_M)) _M (∏⁻(_S,_P))

  SEPARATOR
  
  RULE "(rd1, subaltern) ∏⁺(S,P) ⇒ ∑⁺(S,P)" IS FROM ∏⁺(S,P) INFER ∑⁺(S,P)
  RULE "(rd2, subaltern) ∏⁻(S,P) ⇒ ∑⁻(S,P)" IS FROM ∏⁻(S,P) INFER ∑⁻(S,P)
  RULE "(rd3, conversion) ∑⁺(P,S) ⇒ ∑⁺(S,P)" IS FROM ∑⁺(P,S) INFER ∑⁺(S,P)
  RULE "(rd4, conversion) ∏⁻(S,P) ⇒ ∏⁻(P,S)" IS FROM  ∏⁻(S,P) INFER ∏⁻(P,S)

  SEPARATOR
  
  ENTRY contra IS "contra-tac"
  ENTRY "equiv (∏⁻,∑⁺)" IS WHEN (LETHYP (∏⁻(_S,_P)) (ForwardOrBackward ForwardCut 0 (LAYOUT " " ALL equiv'0)))
                                (LETHYP (∑⁺(_S,_P)) (ForwardOrBackward ForwardCut 0 (LAYOUT " " ALL equiv'1)))
                                (LETHYP _A (Fail ("equiv is not applicable to hypothesis %t", _A)))
                                (LETGOAL (∏⁻(_P,_S)) (LAYOUT " " ALL equiv'0))
                                (LETGOAL (∑⁺(_P,_S)) (LAYOUT " " ALL equiv'1))
                                (LETGOAL _A (Fail ("equiv is not applicable to goal %t", _A)))
                                (Fail "can't happen: equiv entry out of alternatives")
  
  ENTRY "subaltern (∏⁺⇒∑⁺,∏⁻⇒∑⁻)" IS WHEN (LETHYP (∏⁺(_S,_P)) (ForwardOrBackward ForwardCut 0 (LAYOUT " " ALL subaltern'0)))
                                          (LETHYP (∏⁻(_S,_P)) (ForwardOrBackward ForwardCut 0 (LAYOUT " " ALL subaltern'1)))
                                          (LETHYP _A (Fail ("subaltern is not applicable to hypothesis %t", _A)))
                                          (LETGOAL (∑⁺(_S,_P)) (LAYOUT " " ALL subaltern'0))
                                          (LETGOAL (∑⁻(_S,_P)) (LAYOUT " " ALL subaltern'1))
                                          (LETGOAL _A (Fail ("subaltern is not applicable to goal %t", _A)))
                                          (Fail "can't happen: subaltern entry out of alternatives")

  SEPARATOR
  
  ENTRY IP IS (LAYOUT " " ALL IP)
  
  SEPARATOR
  
  ENTRY hyp IS (WHEN (LETHYP _A ("hyp-quiet2" _A))
                     ("hyp-quiet")
               )
END

CONJECTUREPANEL "Syllogisms"
  THEOREM   "Bocardo: ∑⁻(M,P), ∏⁺(M,S) ⊢ ∑⁻(S,P)" IS ∑⁻(M,P), ∏⁺(M,S) ⊢ ∑⁻(S,P)
  THEOREM   "Baroco : ∏⁺(P,M), ∑⁻(S,M) ⊢ ∑⁻(S,P)" IS ∏⁺(P,M), ∑⁻(S,M) ⊢ ∑⁻(S,P)
  THEOREM   "Disamis: ∑⁺(M,P), ∏⁺(M,S) ⊢ ∑⁺(S,P)" IS ∑⁺(M,P), ∏⁺(M,S) ⊢ ∑⁺(S,P)
  THEOREM   "Festino: ∏⁻(P,M), ∑⁺(S,M) ⊢ ∑⁻(S,P)" IS ∏⁻(P,M), ∑⁺(S,M) ⊢ ∑⁻(S,P)
  THEOREM   "Calemes: ∏⁺(P,M), ∏⁻(M,S) ⊢ ∏⁻(S,P)" IS ∏⁺(P,M), ∏⁻(M,S) ⊢ ∏⁻(S,P)
  THEOREM  "Fresison: ∏⁻(P,M), ∑⁺(M,S) ⊢ ∑⁻(S,P)" IS ∏⁻(P,M), ∑⁺(M,S) ⊢ ∑⁻(S,P)
  THEOREM   "Dimatis: ∑⁺(P,M), ∏⁺(M,S) ⊢ ∑⁺(S,P)" IS ∑⁺(P,M), ∏⁺(M,S) ⊢ ∑⁺(S,P)
  THEOREM "Camestres: ∏⁺(P,M), ∏⁻(S,M) ⊢ ∏⁻(S,P)" IS ∏⁺(P,M), ∏⁻(S,M) ⊢ ∏⁻(S,P)
  THEOREM   "Ferison: ∏⁻(M,P), ∑⁺(M,S) ⊢ ∑⁻(S,P)" IS ∏⁻(M,P), ∑⁺(M,S) ⊢ ∑⁻(S,P)
  THEOREM     "Darii: ∏⁺(M,P), ∑⁺(S,M) ⊢ ∑⁺(S,P)" IS ∏⁺(M,P), ∑⁺(S,M) ⊢ ∑⁺(S,P)
  THEOREM    "Cesare: ∏⁻(P,M), ∏⁺(S,M) ⊢ ∏⁻(S,P)" IS ∏⁻(P,M), ∏⁺(S,M) ⊢ ∏⁻(S,P)
  THEOREM    "Datisi: ∏⁺(M,P), ∑⁺(M,S) ⊢ ∑⁺(S,P)" IS ∏⁺(M,P), ∑⁺(M,S) ⊢ ∑⁺(S,P)
  THEOREM     "Ferio: ∏⁻(M,P), ∑⁺(S,M) ⊢ ∑⁻(S,P)" IS ∏⁻(M,P), ∑⁺(S,M) ⊢ ∑⁻(S,P)
  THEOREM   "Bamalip: ∏⁺(P,M), ∏⁺(M,S) ⊢ ∑⁺(S,P)" IS ∏⁺(P,M), ∏⁺(M,S) ⊢ ∑⁺(S,P)
  THEOREM   "Calemos: ∏⁺(P,M), ∏⁻(M,S) ⊢ ∑⁻(S,P)" IS ∏⁺(P,M), ∏⁻(M,S) ⊢ ∑⁻(S,P)
  THEOREM    "Fesapo: ∏⁻(P,M), ∏⁺(M,S) ⊢ ∑⁻(S,P)" IS ∏⁻(P,M), ∏⁺(M,S) ⊢ ∑⁻(S,P)
  THEOREM   "Barbari: ∏⁺(M,P), ∏⁺(S,M) ⊢ ∑⁺(S,P)" IS ∏⁺(M,P), ∏⁺(S,M) ⊢ ∑⁺(S,P)
  THEOREM  "Felapton: ∏⁻(M,P), ∏⁺(M,S) ⊢ ∑⁻(S,P)" IS ∏⁻(M,P), ∏⁺(M,S) ⊢ ∑⁻(S,P)
  THEOREM "Camestros: ∏⁺(P,M), ∏⁻(S,M) ⊢ ∑⁻(S,P)" IS ∏⁺(P,M), ∏⁻(S,M) ⊢ ∑⁻(S,P)
  THEOREM  "Celaront: ∏⁻(M,P), ∏⁺(S,M) ⊢ ∑⁻(S,P)" IS ∏⁻(M,P), ∏⁺(S,M) ⊢ ∑⁻(S,P)
  THEOREM   "Darapti: ∏⁺(M,P), ∏⁺(M,S) ⊢ ∑⁺(S,P)" IS ∏⁺(M,P), ∏⁺(M,S) ⊢ ∑⁺(S,P)
  THEOREM    "Cesaro: ∏⁻(P,M), ∏⁺(S,M) ⊢ ∑⁻(S,P)" IS ∏⁻(P,M), ∏⁺(S,M) ⊢ ∑⁻(S,P)
END
