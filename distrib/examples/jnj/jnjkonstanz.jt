/*
        This jape theory file was generated from the
        latex source of the paper -- ``JnJ in Jape'' --
        which describes the way in which the logic of the
        Woodcock/Davies book is encoded in Jape. A full
        explanation of how the Jape encoding
        may be used with the book is given in that paper,
        and a description of using the logic with the X
        implementation of Jape is given in the
        companion paper ``Using JnJ in Unix Jape''.

        $Id$
*/
        FONTS   "Konstanz"
        SEQUENT IS BAG æ FORMULA
        INITIALISE autoAdditiveLeft true
        PREFIX   350 Â
        INFIX    50R  ê
        INFIX    100R ç
        INFIX    200L ë
        INFIX    300L ¦
        JUXTFIX  4000
        CLASS FORMULA  p q r s
        CLASS VARIABLE x y z
        CONSTANT false true
        SUBSTFIX 5000 [ p / x ]
        RULE  "¦-intro"  FROM p AND q INFER p¦q
        RULE  "¦-elim1"  FROM p¦q INFER p
        RULE  "¦-elim2"  FROM p¦q INFER q

        RULE  "ë-intro1" FROM p INFER pëq
        RULE  "ë-intro2" FROM q INFER pëq
        RULE  "ë-elim"   FROM pëq AND pær AND qær INFER r

        RULE  "ç-intro"  FROM p æ q INFER pçq
        RULE  "ç-elim"   FROM pçq AND p INFER q

        RULE  "Â-intro"  FROM p æ false INFER Â p
        RULE  "Â-elim"   FROM Âp AND p INFER false

        RULE  "false-elim" FROM Âp æ false INFER  p
        RULE  "true-intro" INFER  æ true

        RULE  "ê-intro"  FROM p ç q AND   q ç p INFER p ê q
        RULE  "ê-elim1"  FROM p ê q INFER p ç q
        RULE  "ê-elim2"  FROM p ê q INFER q ç p
        RULE hypothesis(p) INFER p æ p
        RULE cut(p)        FROM  æ p AND   p æ q  INFER   æ q
        RULE thin(p)       FROM  æ q              INFER p æ q
        RULE dup(p)        FROM  p, p æ q         INFER p æ q
        IDENTITY RULE hypothesis
        CUT      RULE cut
        WEAKEN   RULE thin
    INFIX   1000R Ú
    LEFTFIX 20    è : ¥
    LEFTFIX 20    è : | ¥
    LEFTFIX 20    ä : ¥
    LEFTFIX 20    ä : | ¥
    CLASS FORMULA a b t
    BIND x SCOPE p IN è x:a ¥ p
    BIND x SCOPE p q IN è x:a | p ¥ q
    BIND x SCOPE p IN ä x:a ¥ p
    BIND x SCOPE p q IN ä x:a | p ¥ q
    RULE    "è-intro"(OBJECT y) WHERE FRESH y
    FROM    yÚa æ q[y/x]
    INFER   è x:a ¥ q
    RULE    "è-elim"(t)
    FROM    è x:a ¥ q
    AND     tÚa
    INFER   q[t/x]
    RULE    "ä-intro"(t)
    FROM    tÚa
    AND     q[t/x]
    INFER   ä x:a ¥ q
    RULE    "ä-elim"(OBJECT y)
    WHERE   FRESH y
    AND     y NOTIN ä x:a ¥ p
    AND     y NOTIN r
    FROM    ä x:a ¥ p
    AND     yÚa, p[y/x] æ r
    INFER   r
    RULE "è|¥-intro" IS FROM è x:a ¥ p ç q INFER è x:a|p¥q
    RULE "è|¥-elim"  IS FROM è x:a | p ¥ q INFER è x:a¥pçq
    RULE "ä|¥-intro" IS FROM ä x:a ¥ p ¦ q INFER ä x:a|p¥q
    RULE "ä|¥-elim"  IS FROM ä x:a | p ¥ q INFER ä x:a¥p¦q
    TACTIC ElimRule(rule)
    (WHEN
      (LETHYP _p
          (ALT (SEQ      (WITHARGSEL rule) (WITHHYPSEL hypothesis))
               (SEQ  cut (WITHARGSEL rule) (WITHHYPSEL hypothesis))
               (Fail ("%s is not applicable to formula %s", rule, _p))))
      (LETCONC _p
          (ElimRuleBackward rule))
      (Fail ("Select an assumption-like formula before applying %s forwards", rule)))
    TACTIC IntroRule(rule)
    (WHEN  (LETARGSEL _p (SEQ (cut _p) rule))
           (ALT (LETHYP    _p rule)
                rule
                (MESSAGE (rule is not applicable))))
    TACTIC QuantIntroRule(rule)
    (ALT (WITHARGSEL rule)
         (Fail ("%s is not applicable", rule)))
    MENU    "Propositional Rules"

    ENTRY   "hypothesis"
    SEPARATOR
    ENTRY    "false-elim"   IS (IntroRule "false-elim")
    SEPARATOR
    SEPARATOR
    ENTRY    "¦-intro"      IS (IntroRule "¦-intro")
    TACTIC   "¦-elim-1"     IS (ElimRule  "¦-elim1")
    ENTRY    "¦-elim-2"     IS (ElimRule  "¦-elim2")
    SEPARATOR
    ENTRY    "ë-intro1"     IS (IntroRule "ë-intro1")
    ENTRY    "ë-intro2"     IS (IntroRule "ë-intro2")
    ENTRY    "ë-elim"       IS (ElimRule "ë-elim")
    SEPARATOR
    ENTRY    "ç-intro"      IS (IntroRule "ç-intro")
    ENTRY    "ç-elim"       IS (ElimRule  "ç-elim")
    SEPARATOR
    ENTRY    "Â-intro"      IS (IntroRule "Â-intro")
    ENTRY    "Â-elim"       IS (ElimRule "Â-elim")
    ENTRY    "true-intro"   IS (IntroRule "true-intro")
    SEPARATOR
    ENTRY    "ê-intro"      IS (IntroRule "ê-intro")
    ENTRY    "ê-elim1"      IS (ElimRule "ê-elim1")
    ENTRY    "ê-elim2"      IS (ElimRule "ê-elim2")
END

MENU "Predicate Rules" IS
    ENTRY "è-intro"   IS QuantIntroRule "è-intro"
    ENTRY "è-elim"    IS ElimRule "è-elim"
    ENTRY "ä-intro"   IS QuantIntroRule "ä-intro"
    ENTRY "ä-elim"    IS ElimRule "ä-elim"
    ENTRY "ä|¥-intro" IS QuantIntroRule "ä|¥-intro"
    ENTRY "ä|¥-elim"  IS ElimRule "ä|¥-elim"
    ENTRY "è|¥-intro" IS QuantIntroRule "è|¥-intro"
    ENTRY "è|¥-elim"  IS ElimRule "è|¥-elim"
END
    AUTOMATCH hypothesis
    HYPHIT pëq æ r IS  (ALT (ElimRule "ë-elim")  "ë-elim")
    HYPHIT pçq æ r IS  (ALT (ElimRule "ç-elim")  "ç-elim")
    HYPHIT Âp  æ r IS  (ALT (ElimRule "Â-elim")  "Â-elim")
    HYPHIT èx:a|p¥q æ r IS ElimRule "è|¥-elim"
    HYPHIT äx:a|p¥q æ r IS ElimRule "ä|¥-elim"
    HYPHIT èx:a¥q   æ r IS ElimRule "è-elim"
    HYPHIT äx:a¥q   æ r IS ElimRule "ä-elim"
    HYPHIT p¦q æ r IS
    (ALT (SEQ  "¦-elim1"  (hypothesis(p¦q)))
         (SEQ  "¦-elim2"  (hypothesis(p¦q)))
         (SEQ
               cut "¦-elim1" (hypothesis (p¦q))
               cut "¦-elim2" (hypothesis (p¦q))
         ))

    HYPHIT pêq æ r IS
    (ALT (SEQ  "ê-elim1"  (hypothesis(pêq)))
         (SEQ  "ê-elim2"  (hypothesis(pêq)))
         (SEQ
               cut "ê-elim1" (hypothesis (pêq))
               cut "ê-elim2" (hypothesis (pêq))
         ))
    CONCHIT èx:a|p¥q IS QuantIntroRule "è|¥-intro"
    CONCHIT äx:a|p¥q IS QuantIntroRule "ä|¥-intro"
    CONCHIT èx:a¥q   IS QuantIntroRule "è-intro"
    CONCHIT äx:a¥q   IS QuantIntroRule "ä-intro"
    CONCHIT Âp       IS "Â-intro"
    CONCHIT true     IS "true-intro"
    CONCHIT pçq      IS "ç-intro"
    CONCHIT pêq      IS "ê-intro"
    CONCHIT p¦q      IS "¦-intro"
    CONCHIT qër      IS
     (ALT  (SEQ "ë-intro1" hypothesis)
           (SEQ "ë-intro2" hypothesis)
           (MESSAGE (Neither disjunct q nor disjunct r is available)))

    CONCHIT  p æ p IS
    (WHEN (LETHYP _p (WITHHYPSEL hypothesis))
          (Fail ("Please select the hypothesis you want to use")))
    MENU Edit
        RADIOBUTTON displaystyle
             "Sequent-Tree display style"  IS tree
        AND  "Box display style"           IS box
        INITIALLY
             box
        END

        RADIOBUTTON autoselect
            "Manual goal selection"    IS false
        AND "Automatic goal selection" IS true
        END

        RADIOBUTTON applyconjectures
            "Only proven theorems may be used as rules" IS false
        AND "Unproven theorems may be used as rules"    IS true
        END

        RADIOBUTTON ElimRuleBackward
            "Forbid backward use of elimination rules" IS
               ElimRuleBackwardNo
        AND "Permit backward use of elimination rules" IS
               ElimRuleBackwardYes
        END

    END /* MENU Edit */

    TACTIC ElimRuleBackwardYes(rule)
           (WITHARGSEL rule)

    TACTIC ElimRuleBackwardNo(rule)
    (Fail ("Select a goal then a non-grey formula before invoking %s",
           rule))
    TACTIC Fail(x) IS
           ((SEQ (ALERT x) FAIL))
    TACTIC FAILSEL(x, y) IS
           (WHEN (LETARGSEL _p ((SEQ (ALERT x) FAIL))) ((SEQ (ALERT y) FAIL)))
    TACTIC MESSAGE(m) IS
    (SEQ (COMMENT m)
         (EXPLAIN m))

    TACTIC SKIP(x)    IS (SEQ)

    MENU    Edit
            SEPARATOR
            RADIOBUTTON Comment IS
                    "Comments on during tactics"  COMMENT
            AND     "Comments off during tactics" SKIP
            END
    END
        INFIX 1000L ‘
CONJECTUREPANEL "Conjectures" IS
    THEOREMS Propositional ARE
        ÂÂp æ p
    AND Â(pëq) æ Âp ¦ Âq
    AND Â(p¦q) æ Âp ë Âq
    AND æ p ë Âp
    AND p , Âp æ false
    AND p ¦ Âp æ false
    AND p æ qçp
    AND æ pêp
    AND Â Â p ê p
    AND (pçq) ê (Âpëq)
    AND (pçq) ê (ÂqçÂp)
    AND æ (pçq) ë (qçp)
    AND (p¦q ç r) ç (p ç (q ç r))
    AND p ç q æ p¦q ê p
    AND æ p ç (q ç p)
    AND true  ê Âfalse
    AND Âtrue  ê false
    AND p¦true ê p
    AND pëtrue ê true
    AND p¦false ê false
    AND pëfalse ê p
    AND (pçp) ê true
    AND (pçtrue) ê true
    AND (trueçp) ê p
    AND (pçfalse) ê Âp
    AND (p¦p) ê p
    AND (p¦q) ê (q¦p)
    AND (p¦(q¦r)) ê ((p¦q)¦r)
    AND (pëp) ê p
    AND (pëq) ê (qëp)
    AND (pë(qër)) ê ((pëq)ër)
    AND p ë (q ë r) ê (p ë q) ë r
    AND p ¦ (q ë r) ê (p ¦ q) ë (p ¦ r)
    AND p ë (q ¦ r) ê (p ë q) ¦ (p ë r)
    AND Â(pëq) ê Âp ¦ Âq
    AND Â(p¦q) ê Âp ë Âq
    AND (pçq) ¦ (qçr) ç (pçr)
    AND (pêq) ¦ (qêr) ç (pêr)
    AND Âp ¦ p æ false
    AND Â(pêq)ê((pëq)¦Â(p¦q))
    AND èx:a ¥ p¦q æ (èx:a ¥ p) ¦ (èx:a ¥ q)
    AND (èx:a ¥ p) ¦ (èx:a ¥ q) æ èx:a ¥ p¦q
    AND Â(ä x:a¥q) æ (è x:a¥Âq)
    AND Â(è x:a¥q) æ (ä x:a¥Âq)
    AND Â(è x:a|p¥q) æ (ä x:a|p¥Âq)
    AND WHERE x NOTIN a,a',y AND y NOTIN a,a',x INFER
        äx:a ¥ èy:a' ¥ q æ èy:a' ¥ äx:a ¥ q
    AND p ç q, q ç r , p æ r
    AND p ç q æ (q ç r) ç (p ç r)
    AND p ç (q ç r), p ç q, p æ r
    AND p ç q, q ç r æ p ç r
    AND p ç (q ç r) æ q ç (p ç r)
    AND p ç (q ç (r ç s)) æ r ç (q ç (p ç s ))
    AND p ç (q ç r) æ (p ç q) ç (p ç r)
    AND æ (p ç (q ç r)) ç ((p ç q) ç (p ç r))
    AND (p ¦ q) ç r ê  p ç (q ç r)
    AND q ç r æ (p ë q) ç (p ë r)
    END
    THEOREM "?-äx:a¥èy:a'¥x‘yæèy:a'¥äx:a¥x‘y(no provisos)"
    IS ä x:a ¥ èy:a' ¥ x‘y æ èy:a' ¥ äx:a ¥ x‘y
    THEOREM "?- (pçq)çp" IS (pçq)çp
    THEOREM "?- (pëÂp)çÂp" IS (pëÂp)çÂp
    THEOREM "?- èy:a'¥äx:a¥q æ äx:a¥èy:a'¥q"
    WHERE x NOTIN a,a',y AND y NOTIN a,a',x
    IS èy:a'¥äx:a¥q æ äx:a¥èy:a'¥q
    BUTTON "Apply Forward"   IS apply ThmForward COMMAND
    BUTTON "Apply Backwards" IS apply ThmBackward COMMAND
END /* PANEL */
    TACTIC ThmForward(thm) IS (SEQ cut (WITHHYPSEL (WITHARGSEL thm)))
    TACTIC ThmBackward(thm) IS (WITHARGSEL(APPLYORRESOLVE thm))
        RULE    "rewrite"(p, OBJECT x) WHERE FRESH x
        FROM    p ê q
        AND     r[q/x]
        INFER   r[p/x]

        RULE    "rewritebackwards"(p, OBJECT x) WHERE FRESH x
        FROM    q ê p
        AND     r[q/x]
        INFER   r[p/x]

        RULE    "hyprewrite"(p, OBJECT x) WHERE FRESH x
        FROM    p ê q
        AND     r[p/x] æ s
        INFER   r[q/x] æ s

        RULE    "hyprewritebackwards"(p, OBJECT x) WHERE FRESH x
        FROM    q ê p
        AND     r[p/x] æ s
        INFER   r[q/x] æ s
    CONJECTUREPANEL Conjectures IS
   BUTTON "Rewrite Ç" IS
      apply RewriteWith Unfolding hyprewrite   rewrite COMMAND
     BUTTON "Rewrite È" IS
      apply RewriteWith Folding   hyprewritebackwards rewritebackwards COMMAND
    END
    TACTIC  RewriteWith(foldunfold, hyprewriterule, rewriterule, thm) IS
    (LAYOUT "rewrite %s" (1)
      (ALT
        (WHEN
          (LETHYPSUBSTSEL  _p (WITHSUBSTSEL hyprewriterule) thm)
          (LETCONCSUBSTSEL _p (WITHSUBSTSEL rewriterule) thm))
        (foldunfold thm)
        (FAILSEL ("%s not applicable to text selection", thm)
                 ("%s not applicable anywhere by foldunfold", thm))))
    TACTIC Unfolding(thm) IS (UNFOLD rewrite thm)
    TACTIC Folding(thm)   IS (FOLD   rewritebackwards thm)
    MENU Rewriting
    ENTRY    "Rewrite Ç"  IS
                Rewrite rewrite hyprewrite
    ENTRY    "Rewrite È"  IS
                Rewrite rewritebackwards hyprewritebackwards
    END

    TACTIC  Rewrite(rule, hyprule) IS
    (WHEN   (LETHYPSUBSTSEL  _p (WITHSUBSTSEL hyprule))
            (LETCONCSUBSTSEL _p (WITHSUBSTSEL rule))
            (Fail (Please text-select a subexpression to rewrite)))

CONJECTUREPANEL "Derived rules"
    DERIVED RULE WHERE FRESH y  FROM yÚaæp[y/x]êq[y/x] AND èx:a¥p INFER èx:a¥q
END
    
TACTIC GivenForward(i) IS SEQ cut (GIVEN i)
TACTIC GivenBackward(i) IS GIVEN i

/*
GIVENPANEL Given IS
    BUTTON "Apply Forward"   IS apply GivenForward COMMAND
    BUTTON "Apply Backwards" IS apply GivenBackward COMMAND
END /* GIVENPANEL */
*/
TACTIC GivenTac(i) IS
    ALT (GIVEN i)
          (CUTIN (GIVEN i))

INITIALISE givenMenuTactic GivenTac



